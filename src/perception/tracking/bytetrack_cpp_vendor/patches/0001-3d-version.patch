From 7bd79bab0326988efebdca692bee425f9e9e210c Mon Sep 17 00:00:00 2001
From: khuang9 <k279huan@uwaterloo.ca>
Date: Thu, 29 Jan 2026 04:13:05 -0500
Subject: [PATCH] 3d-version

---
 CMakeLists.txt                   |   4 +-
 include/ByteTrack/KalmanFilter.h |  26 +--
 include/ByteTrack/Rect.h         |  31 +++-
 include/ByteTrack/STrack.h       |  10 +-
 src/BYTETracker.cpp              |   2 +-
 src/KalmanFilter.cpp             |  66 ++++----
 src/Rect.cpp                     | 268 ++++++++++++++++++++++++-------
 src/STrack.cpp                   |  54 +++++--
 8 files changed, 330 insertions(+), 131 deletions(-)

diff --git a/CMakeLists.txt b/CMakeLists.txt
index 7ccd9b3..fa0e513 100644
--- a/CMakeLists.txt
+++ b/CMakeLists.txt
@@ -32,7 +32,7 @@ if(NOT EIGEN3_FOUND)
   FetchContent_MakeAvailable(eigen)
   unset(BUILD_TESTING CACHE)
 endif()
-
+find_package(OpenCV REQUIRED)
 add_library(${PROJECT_NAME} SHARED
   ${CMAKE_CURRENT_SOURCE_DIR}/src/BYTETracker.cpp
   ${CMAKE_CURRENT_SOURCE_DIR}/src/KalmanFilter.cpp
@@ -44,7 +44,7 @@ add_library(${PROJECT_NAME} SHARED
 target_include_directories(${PROJECT_NAME} PUBLIC
   ${CMAKE_CURRENT_SOURCE_DIR}/include
   )
-target_link_libraries(${PROJECT_NAME} Eigen3::Eigen)
+target_link_libraries(${PROJECT_NAME} Eigen3::Eigen ${OpenCV_LIBS})

 # Build the tests if the 'BUILD_BYTETRACK_TEST' variable is set to 'ON'
 set(BUILD_BYTETRACK_TEST OFF CACHE BOOL "The flag whether to build the tests or not")
diff --git a/include/ByteTrack/KalmanFilter.h b/include/ByteTrack/KalmanFilter.h
index 18842a7..d557666 100644
--- a/include/ByteTrack/KalmanFilter.h
+++ b/include/ByteTrack/KalmanFilter.h
@@ -9,31 +9,35 @@ namespace byte_track
 class KalmanFilter
 {
 public:
-    using DetectBox = Xyah<float>;
+    using DetectBox = Xyzolwh<float>;

-    using StateMean = Eigen::Matrix<float, 1, 8, Eigen::RowMajor>;
-    using StateCov = Eigen::Matrix<float, 8, 8, Eigen::RowMajor>;
+    using StateMean = Eigen::Matrix<float, 1, 10, Eigen::RowMajor>;
+    using StateCov = Eigen::Matrix<float, 10, 10, Eigen::RowMajor>;

-    using StateHMean = Eigen::Matrix<float, 1, 4, Eigen::RowMajor>;
-    using StateHCov = Eigen::Matrix<float, 4, 4, Eigen::RowMajor>;
+    using StateHMean = Eigen::Matrix<float, 1, 7, Eigen::RowMajor>;
+    using StateHCov = Eigen::Matrix<float, 7, 7, Eigen::RowMajor>;

-    KalmanFilter(const float& std_weight_position = 1. / 20,
-                 const float& std_weight_velocity = 1. / 160);
+    KalmanFilter(const float& std_weight_position = 1.,
+                 const float& std_weight_velocity = 1.,
+                 const float& alpha = 1.,
+                 const float& beta = 2.);

     void initiate(StateMean& mean, StateCov& covariance, const DetectBox& measurement);

     void predict(StateMean& mean, StateCov& covariance);

-    void update(StateMean& mean, StateCov& covariance, const DetectBox& measurement);
+    void update(StateMean& mean, StateCov& covariance, const DetectBox& measurement, const float& confidence);

 private:
     float std_weight_position_;
     float std_weight_velocity_;
+    float alpha_;
+    float beta_;

-    Eigen::Matrix<float, 8, 8, Eigen::RowMajor> motion_mat_;
-    Eigen::Matrix<float, 4, 8, Eigen::RowMajor> update_mat_;
+    Eigen::Matrix<float, 10, 10, Eigen::RowMajor> motion_mat_;
+    Eigen::Matrix<float, 7, 10, Eigen::RowMajor> update_mat_;

     void project(StateHMean &projected_mean, StateHCov &projected_covariance,
-                 const StateMean& mean, const StateCov& covariance);
+                 const StateMean& mean, const StateCov& covariance, const float& confidence);
 };
 }
\ No newline at end of file
diff --git a/include/ByteTrack/Rect.h b/include/ByteTrack/Rect.h
index b5ab291..18116d5 100644
--- a/include/ByteTrack/Rect.h
+++ b/include/ByteTrack/Rect.h
@@ -1,6 +1,8 @@
 #pragma once

 #include "Eigen/Dense"
+#include <opencv2/opencv.hpp>
+#include <math.h>

 namespace byte_track
 {
@@ -13,35 +15,48 @@ using Tlbr = Eigen::Matrix<T, 1, 4, Eigen::RowMajor>;
 template<typename T>
 using Xyah = Eigen::Matrix<T, 1, 4, Eigen::RowMajor>;

+template<typename T>
+using Xyzolwh = Eigen::Matrix<T, 1, 7, Eigen::RowMajor>;
+
 template<typename T>
 class Rect
 {
     public:
-    Tlwh<T> tlwh;
+    Xyzolwh<T> xyzolwh;

     Rect() = default;
-    Rect(const T &x, const T &y, const T &width, const T &height);
+    Rect(const T &x, const T &y, const T &z, const T &yaw, const T &length, const T &width, const T &height);

     ~Rect();

     const T &x() const;
     const T &y() const;
+    const T &z() const;
+    const T &yaw() const;
+    const T &length() const;
     const T &width() const;
     const T &height() const;

     T &x();
     T &y();
+    T &z();
+    T &yaw();
+    T &length();
     T &width();
     T &height();

-    const T &tl_x() const;
-    const T &tl_y() const;
-    T br_x() const;
-    T br_y() const;
+    // const T &tl_x() const;
+    // const T &tl_y() const;
+    // T br_x() const;
+    // T br_y() const;

-    Tlbr<T> getTlbr() const;
-    Xyah<T> getXyah() const;
+    // Tlbr<T> getTlbr() const;
+    // Xyah<T> getXyah() const;
+    Xyzolwh<T> getXyzolwh() const;

+    cv::Point2f rotated(const float &dx, const float &dy) const;
+    float minEnclosingBoxDiag(const Rect<T>& other) const;
+    float calcBEVIntersection(const Rect<T>& other) const;
     float calcIoU(const Rect<T>& other) const;
 };

diff --git a/include/ByteTrack/STrack.h b/include/ByteTrack/STrack.h
index 476ed11..6aa99ae 100644
--- a/include/ByteTrack/STrack.h
+++ b/include/ByteTrack/STrack.h
@@ -17,7 +17,7 @@ enum class STrackState {
 class STrack
 {
 public:
-    STrack(const Rect<float>& rect, const float& score);
+    STrack(const Rect<float>& rect, const float& score, const int& class_id);
     ~STrack();

     const Rect<float>& getRect() const;
@@ -25,11 +25,14 @@ public:

     const bool& isActivated() const;
     const float& getScore() const;
+    const int& getClassId() const;
+    const std::unordered_map<int, int>& getClassCount() const;
     const size_t& getTrackId() const;
     const size_t& getFrameId() const;
     const size_t& getStartFrameId() const;
     const size_t& getTrackletLength() const;

+    void updateClass(int new_class_id);
     void activate(const size_t& frame_id, const size_t& track_id);
     void reActivate(const STrack &new_track, const size_t &frame_id, const int &new_track_id = -1);

@@ -49,11 +52,14 @@ private:

     bool is_activated_;
     float score_;
+    int class_id_;
     size_t track_id_;
     size_t frame_id_;
     size_t start_frame_id_;
     size_t tracklet_len_;

+    std::unordered_map<int, int> class_count_;
+
     void updateRect();
 };
-}
\ No newline at end of file
+}
diff --git a/src/BYTETracker.cpp b/src/BYTETracker.cpp
index a02abc1..31ba5bf 100644
--- a/src/BYTETracker.cpp
+++ b/src/BYTETracker.cpp
@@ -37,7 +37,7 @@ std::vector<byte_track::BYTETracker::STrackPtr> byte_track::BYTETracker::update(

     for (const auto &object : objects)
     {
-        const auto strack = std::make_shared<STrack>(object.rect, object.prob);
+        const auto strack = std::make_shared<STrack>(object.rect, object.prob, object.label);
         if (object.prob >= track_thresh_)
         {
             det_stracks.push_back(strack);
diff --git a/src/KalmanFilter.cpp b/src/KalmanFilter.cpp
index a425bd2..054c523 100644
--- a/src/KalmanFilter.cpp
+++ b/src/KalmanFilter.cpp
@@ -1,38 +1,39 @@
 #include "ByteTrack/KalmanFilter.h"

+#include <cmath>
 #include <cstddef>

 byte_track::KalmanFilter::KalmanFilter(const float& std_weight_position,
-                                       const float& std_weight_velocity) :
+                                       const float& std_weight_velocity,
+                                       const float& alpha,
+                                       const float& beta) :
     std_weight_position_(std_weight_position),
-    std_weight_velocity_(std_weight_velocity)
+    std_weight_velocity_(std_weight_velocity),
+    alpha_(alpha),
+    beta_(beta)
 {
-    constexpr size_t ndim = 4;
+    constexpr size_t ndim = 3;
     constexpr float dt = 1;

-    motion_mat_ = Eigen::MatrixXf::Identity(8, 8);
-    update_mat_ = Eigen::MatrixXf::Identity(4, 8);
+    motion_mat_ = Eigen::MatrixXf::Identity(10, 10);
+    update_mat_ = Eigen::MatrixXf::Identity(7, 10);

     for (size_t i = 0; i < ndim; i++)
     {
-        motion_mat_(i, ndim + i) = dt;
+        motion_mat_(i, 4 + ndim + i) = dt;
     }
 }

 void byte_track::KalmanFilter::initiate(StateMean &mean, StateCov &covariance, const DetectBox &measurement)
 {
-    mean.block<1, 4>(0, 0) = measurement.block<1, 4>(0, 0);
-    mean.block<1, 4>(0, 4) = Eigen::Vector4f::Zero();
+    mean.block<1, 7>(0, 0) = measurement.block<1, 7>(0, 0);
+    mean.block<1, 3>(0, 7) = Eigen::Vector3f::Zero();

     StateMean std;
-    std(0) = 2 * std_weight_position_ * measurement[3];
-    std(1) = 2 * std_weight_position_ * measurement[3];
-    std(2) = 1e-2;
-    std(3) = 2 * std_weight_position_ * measurement[3];
-    std(4) = 10 * std_weight_velocity_ * measurement[3];
-    std(5) = 10 * std_weight_velocity_ * measurement[3];
-    std(6) = 1e-5;
-    std(7) = 10 * std_weight_velocity_ * measurement[3];
+    for (int i = 0; i < 7; ++i)
+        std(i) = 10 * std_weight_position_;
+    for (int i = 7; i < 10; ++i)
+        std(i) = 10000 * std_weight_velocity_;

     StateMean tmp = std.array().square();
     covariance = tmp.asDiagonal();
@@ -41,14 +42,10 @@ void byte_track::KalmanFilter::initiate(StateMean &mean, StateCov &covariance, c
 void byte_track::KalmanFilter::predict(StateMean &mean, StateCov &covariance)
 {
     StateMean std;
-    std(0) = std_weight_position_ * mean(3);
-    std(1) = std_weight_position_ * mean(3);
-    std(2) = 1e-2;
-    std(3) = std_weight_position_ * mean(3);
-    std(4) = std_weight_velocity_ * mean(3);
-    std(5) = std_weight_velocity_ * mean(3);
-    std(6) = 1e-5;
-    std(7) = std_weight_velocity_ * mean(3);
+    for (int i = 0; i < 7; ++i)
+        std(i) = std_weight_position_;
+    for (int i = 7; i < 10; ++i)
+        std(i) = 0.01 * std_weight_velocity_;

     StateMean tmp = std.array().square();
     StateCov motion_cov = tmp.asDiagonal();
@@ -57,15 +54,15 @@ void byte_track::KalmanFilter::predict(StateMean &mean, StateCov &covariance)
     covariance = motion_mat_ * covariance * (motion_mat_.transpose()) + motion_cov;
 }

-void byte_track::KalmanFilter::update(StateMean &mean, StateCov &covariance, const DetectBox &measurement)
+void byte_track::KalmanFilter::update(StateMean &mean, StateCov &covariance, const DetectBox &measurement, const float &confidence)
 {
     StateHMean projected_mean;
     StateHCov projected_cov;
-    project(projected_mean, projected_cov, mean, covariance);
+    project(projected_mean, projected_cov, mean, covariance, confidence);

-    Eigen::Matrix<float, 4, 8> B = (covariance * (update_mat_.transpose())).transpose();
-    Eigen::Matrix<float, 8, 4> kalman_gain = (projected_cov.llt().solve(B)).transpose();
-    Eigen::Matrix<float, 1, 4> innovation = measurement - projected_mean;
+    Eigen::Matrix<float, 7, 10> B = (covariance * (update_mat_.transpose())).transpose();
+    Eigen::Matrix<float, 10, 7> kalman_gain = (projected_cov.llt().solve(B)).transpose();
+    Eigen::Matrix<float, 1, 7> innovation = measurement - projected_mean;

     const auto tmp = innovation * (kalman_gain.transpose());
     mean = (mean.array() + tmp.array()).matrix();
@@ -73,17 +70,16 @@ void byte_track::KalmanFilter::update(StateMean &mean, StateCov &covariance, con
 }

 void byte_track::KalmanFilter::project(StateHMean &projected_mean, StateHCov &projected_covariance,
-                                       const StateMean& mean, const StateCov& covariance)
+                                       const StateMean& mean, const StateCov& covariance, const float &confidence)
 {
     DetectBox std;
-    std << std_weight_position_ * mean(3),
-           std_weight_position_ * mean(3),
-           1e-1,
-           std_weight_position_ * mean(3);
+    for (int i = 0; i < 7; ++i)
+        std(i) = std_weight_position_;

     projected_mean = update_mat_ * mean.transpose();
     projected_covariance = update_mat_ * covariance * (update_mat_.transpose());

-    Eigen::Matrix<float, 4, 4> diag = std.asDiagonal();
+    Eigen::Matrix<float, 7, 7> diag = (1 + alpha_*std::pow(1 - confidence, beta_)) * (std.asDiagonal());
     projected_covariance += diag.array().square().matrix();
 }
+
diff --git a/src/Rect.cpp b/src/Rect.cpp
index 48d1691..21cc405 100644
--- a/src/Rect.cpp
+++ b/src/Rect.cpp
@@ -1,10 +1,12 @@
 #include "ByteTrack/Rect.h"

 #include <algorithm>
+#include <cmath>
+#include <opencv2/opencv.hpp>

 template <typename T>
-byte_track::Rect<T>::Rect(const T &x, const T &y, const T &width, const T &height) :
-    tlwh({x, y, width, height})
+byte_track::Rect<T>::Rect(const T &x, const T &y, const T &z, const T &yaw, const T &length, const T &width, const T &height) :
+    xyzolwh({x, y, z, yaw, length, width, height})
 {
 }

@@ -16,134 +18,280 @@ byte_track::Rect<T>::~Rect()
 template <typename T>
 const T& byte_track::Rect<T>::x() const
 {
-    return tlwh[0];
+    return xyzolwh[0];
 }

 template <typename T>
 const T& byte_track::Rect<T>::y() const
 {
-    return tlwh[1];
+    return xyzolwh[1];
 }

 template <typename T>
-const T& byte_track::Rect<T>::width() const
+const T& byte_track::Rect<T>::z() const
 {
-    return tlwh[2];
+    return xyzolwh[2];
 }

 template <typename T>
-const T& byte_track::Rect<T>::height() const
+const T& byte_track::Rect<T>::yaw() const
 {
-    return tlwh[3];
+    return xyzolwh[3];
 }

 template <typename T>
-T& byte_track::Rect<T>::x()
+const T& byte_track::Rect<T>::length() const
 {
-    return tlwh[0];
+    return xyzolwh[4];
 }

 template <typename T>
-T& byte_track::Rect<T>::y()
+const T& byte_track::Rect<T>::width() const
 {
-    return tlwh[1];
+    return xyzolwh[5];
 }

 template <typename T>
-T& byte_track::Rect<T>::width()
+const T& byte_track::Rect<T>::height() const
 {
-    return tlwh[2];
+    return xyzolwh[6];
 }

 template <typename T>
-T& byte_track::Rect<T>::height()
+T& byte_track::Rect<T>::x()
 {
-    return tlwh[3];
+    return xyzolwh[0];
 }

 template <typename T>
-const T& byte_track::Rect<T>::tl_x() const
+T& byte_track::Rect<T>::y()
 {
-    return tlwh[0];
+    return xyzolwh[1];
 }

 template <typename T>
-const T& byte_track::Rect<T>::tl_y() const
+T& byte_track::Rect<T>::z()
 {
-    return tlwh[1];
+    return xyzolwh[2];
 }

 template <typename T>
-T byte_track::Rect<T>::br_x() const
+T& byte_track::Rect<T>::yaw()
 {
-    return tlwh[0] + tlwh[2];
+    return xyzolwh[3];
 }

 template <typename T>
-T byte_track::Rect<T>::br_y() const
+T& byte_track::Rect<T>::length()
 {
-    return tlwh[1] + tlwh[3];
+    return xyzolwh[4];
 }

 template <typename T>
-byte_track::Tlbr<T> byte_track::Rect<T>::getTlbr() const
+T& byte_track::Rect<T>::width()
 {
-    return {
-        tlwh[0],
-        tlwh[1],
-        tlwh[0] + tlwh[2],
-        tlwh[1] + tlwh[3],
-    };
+    return xyzolwh[5];
 }

 template <typename T>
-byte_track::Xyah<T> byte_track::Rect<T>::getXyah() const
+T& byte_track::Rect<T>::height()
+{
+    return xyzolwh[6];
+}
+
+// template <typename T>
+// const T& byte_track::Rect<T>::tl_x() const
+// {
+//     return tlwh[0];
+// }
+
+// template <typename T>
+// const T& byte_track::Rect<T>::tl_y() const
+// {
+//     return tlwh[1];
+// }
+
+// template <typename T>
+// T byte_track::Rect<T>::br_x() const
+// {
+//     return tlwh[0] + tlwh[2];
+// }
+
+// template <typename T>
+// T byte_track::Rect<T>::br_y() const
+// {
+//     return tlwh[1] + tlwh[3];
+// }
+
+// template <typename T>
+// byte_track::Tlbr<T> byte_track::Rect<T>::getTlbr() const
+// {
+//     return {
+//         tlwh[0],
+//         tlwh[1],
+//         tlwh[0] + tlwh[2],
+//         tlwh[1] + tlwh[3],
+//     };
+// }
+
+// template <typename T>
+// byte_track::Xyah<T> byte_track::Rect<T>::getXyah() const
+// {
+//     return {
+//         tlwh[0] + tlwh[2] / 2,
+//         tlwh[1] + tlwh[3] / 2,
+//         tlwh[2] / tlwh[3],
+//         tlwh[3],
+//     };
+// }
+
+template <typename T>
+byte_track::Xyzolwh<T> byte_track::Rect<T>::getXyzolwh() const
 {
     return {
-        tlwh[0] + tlwh[2] / 2,
-        tlwh[1] + tlwh[3] / 2,
-        tlwh[2] / tlwh[3],
-        tlwh[3],
+        xyzolwh[0],
+        xyzolwh[1],
+        xyzolwh[2],
+        xyzolwh[3],
+        xyzolwh[4],
+        xyzolwh[5],
+        xyzolwh[6],
     };
 }

 template<typename T>
-float byte_track::Rect<T>::calcIoU(const Rect<T>& other) const
+cv::Point2f byte_track::Rect<T>::rotated(const float &dx, const float &dy) const
 {
-    const float box_area = (other.tlwh[2] + 1) * (other.tlwh[3] + 1);
-    const float iw = std::min(tlwh[0] + tlwh[2], other.tlwh[0] + other.tlwh[2]) - std::max(tlwh[0], other.tlwh[0]) + 1;
-    float iou = 0;
-    if (iw > 0)
-    {
-        const float ih = std::min(tlwh[1] + tlwh[3], other.tlwh[1] + other.tlwh[3]) - std::max(tlwh[1], other.tlwh[1]) + 1;
-        if (ih > 0)
-        {
-            const float ua = (tlwh[0] + tlwh[2] - tlwh[0] + 1) * (tlwh[1] + tlwh[3] - tlwh[1] + 1) + box_area - iw * ih;
-            iou = iw * ih / ua;
-        }
-    }
-    return iou;
+    float yaw = xyzolwh[3];
+    return cv::Point2f(
+        xyzolwh[0] + dx * std::cos(yaw) - dy * std::sin(yaw),
+        xyzolwh[1] + dx * std::sin(yaw) + dy * std::cos(yaw)
+    );
+}
+
+template<typename T>
+float byte_track::Rect<T>::minEnclosingBoxDiag(const Rect<T>& other) const
+{
+    std::vector<cv::Point2f> points = {
+        rotated(-xyzolwh[4]/2, -xyzolwh[5]/2),
+        rotated(xyzolwh[4]/2, -xyzolwh[5]/2),
+        rotated(xyzolwh[4]/2, xyzolwh[5]/2),
+        rotated(-xyzolwh[4]/2, xyzolwh[5]/2),
+        other.rotated(-other.xyzolwh[4]/2, -other.xyzolwh[5]/2),
+        other.rotated(other.xyzolwh[4]/2, -other.xyzolwh[5]/2),
+        other.rotated(other.xyzolwh[4]/2, other.xyzolwh[5]/2),
+        other.rotated(-other.xyzolwh[4]/2, other.xyzolwh[5]/2)
+    };
+
+    cv::RotatedRect minrect = cv::minAreaRect(points);
+    cv::Point2f verts[4];
+    minrect.points(verts);
+
+    float dx = verts[0].x - verts[2].x;
+    float dy = verts[0].y - verts[2].y;
+
+    float max_z = std::max(xyzolwh[2] + xyzolwh[6] / 2, other.xyzolwh[2] + other.xyzolwh[6] / 2);
+    float min_z = std::min(xyzolwh[2] - xyzolwh[6] / 2, other.xyzolwh[2] - other.xyzolwh[6] / 2);
+    float height = max_z - min_z;
+
+    return std::sqrt(dx*dx + dy*dy + height*height);
 }

 template<typename T>
-byte_track::Rect<T> byte_track::generate_rect_by_tlbr(const byte_track::Tlbr<T>& tlbr)
+float byte_track::Rect<T>::calcBEVIntersection(const Rect<T>& other) const
 {
-    return byte_track::Rect<T>(tlbr[0], tlbr[1], tlbr[2] - tlbr[0], tlbr[3] - tlbr[1]);
+    thread_local std::vector<cv::Point2f> inter_poly;
+    inter_poly.clear();
+
+    float length = xyzolwh[4], width = xyzolwh[5];
+    float other_length = other.xyzolwh[4], other_width = other.xyzolwh[5];
+    float yaw_deg = -xyzolwh[3] * 180.0f / M_PI;
+    float other_yaw_deg = -other.xyzolwh[3] * 180.0 / M_PI;
+
+    if (width > length) {
+        std::swap(width, length);
+        yaw_deg += 90.0f;
+    }
+
+    if (other_width > other_length) {
+        std::swap(other_width, other_length);
+        other_yaw_deg += 90.0f;
+    }
+
+    cv::RotatedRect rrect(
+        cv::Point2f(xyzolwh[0], xyzolwh[1]),
+        cv::Size2f(length, width),
+        yaw_deg
+    );
+    cv::RotatedRect other_rrect(
+        cv::Point2f(other.xyzolwh[0], other.xyzolwh[1]),
+        cv::Size2f(other_length, other_width),
+        other_yaw_deg
+    );
+
+    int result = cv::rotatedRectangleIntersection(rrect, other_rrect, inter_poly);
+    float inter = 0.0f;
+    if (result != cv::INTERSECT_NONE && !inter_poly.empty()) {
+        inter = static_cast<float>(cv::contourArea(inter_poly));
+    }
+
+    return inter;
+    // float area = length * width;
+    // float other_area = other_length * other_width;
+    // float un = area + other_area - inter;
+
+    // if (un <= 0.0f) return 0.0f;
+    // else return inter / un;
 }

 template<typename T>
-byte_track::Rect<T> byte_track::generate_rect_by_xyah(const byte_track::Xyah<T>& xyah)
+float byte_track::Rect<T>::calcIoU(const Rect<T>& other) const
 {
-    const auto width = xyah[2] * xyah[3];
-    return byte_track::Rect<T>(xyah[0] - width / 2, xyah[1] - xyah[3] / 2, width, xyah[3]);
+    float z_top = std::min(xyzolwh[6]/2, other.xyzolwh[6]/2);
+    float z_bot = std::max(-xyzolwh[6]/2, -other.xyzolwh[6]/2);
+    float z_inter = std::max(0.0f, z_top - z_bot);
+
+    float vol = xyzolwh[4] * xyzolwh[5] * xyzolwh[6];
+    float other_vol = other.xyzolwh[4] * other.xyzolwh[5] * other.xyzolwh[6];
+    float inter_vol = z_inter * calcBEVIntersection(other);
+    float union_vol = vol + other_vol - inter_vol;
+
+    if (union_vol <= 0.0f) return 0.0f;
+    else return inter_vol / union_vol;
+    // const float box_area = (other.tlwh[2] + 1) * (other.tlwh[3] + 1);
+    // const float iw = std::min(tlwh[0] + tlwh[2], other.tlwh[0] + other.tlwh[2]) - std::max(tlwh[0], other.tlwh[0]) + 1;
+    // float iou = 0;
+    // if (iw > 0)
+    // {
+    //     const float ih = std::min(tlwh[1] + tlwh[3], other.tlwh[1] + other.tlwh[3]) - std::max(tlwh[1], other.tlwh[1]) + 1;
+    //     if (ih > 0)
+    //     {
+    //         const float ua = (tlwh[0] + tlwh[2] - tlwh[0] + 1) * (tlwh[1] + tlwh[3] - tlwh[1] + 1) + box_area - iw * ih;
+    //         iou = iw * ih / ua;
+    //     }
+    // }
+    // return iou;
 }

-// explicit instantiation
+// template<typename T>
+// byte_track::Rect<T> byte_track::generate_rect_by_tlbr(const byte_track::Tlbr<T>& tlbr)
+// {
+//     return byte_track::Rect<T>(tlbr[0], tlbr[1], tlbr[2] - tlbr[0], tlbr[3] - tlbr[1]);
+// }
+
+// template<typename T>
+// byte_track::Rect<T> byte_track::generate_rect_by_xyah(const byte_track::Xyah<T>& xyah)
+// {
+//     const auto width = xyah[2] * xyah[3];
+//     return byte_track::Rect<T>(xyah[0] - width / 2, xyah[1] - xyah[3] / 2, width, xyah[3]);
+// }
+
+// // explicit instantiation
 template class byte_track::Rect<int>;
 template class byte_track::Rect<float>;

-template byte_track::Rect<int> byte_track::generate_rect_by_tlbr<int>(const byte_track::Tlbr<int>&);
-template byte_track::Rect<float> byte_track::generate_rect_by_tlbr<float>(const byte_track::Tlbr<float>&);
+// template byte_track::Rect<int> byte_track::generate_rect_by_tlbr<int>(const byte_track::Tlbr<int>&);
+// template byte_track::Rect<float> byte_track::generate_rect_by_tlbr<float>(const byte_track::Tlbr<float>&);

-template byte_track::Rect<int> byte_track::generate_rect_by_xyah<int>(const byte_track::Xyah<int>&);
-template byte_track::Rect<float> byte_track::generate_rect_by_xyah<float>(const byte_track::Xyah<float>&);
+// template byte_track::Rect<int> byte_track::generate_rect_by_xyah<int>(const byte_track::Xyah<int>&);
+// template byte_track::Rect<float> byte_track::generate_rect_by_xyah<float>(const byte_track::Xyah<float>&);
diff --git a/src/STrack.cpp b/src/STrack.cpp
index 744b254..7d9dd79 100644
--- a/src/STrack.cpp
+++ b/src/STrack.cpp
@@ -2,7 +2,7 @@

 #include <cstddef>

-byte_track::STrack::STrack(const Rect<float>& rect, const float& score) :
+byte_track::STrack::STrack(const Rect<float>& rect, const float& score, const int& class_id) :
     kalman_filter_(),
     mean_(),
     covariance_(),
@@ -10,11 +10,13 @@ byte_track::STrack::STrack(const Rect<float>& rect, const float& score) :
     state_(STrackState::New),
     is_activated_(false),
     score_(score),
+    class_id_(class_id),
     track_id_(0),
     frame_id_(0),
     start_frame_id_(0),
     tracklet_len_(0)
 {
+    class_count_[class_id] = 1;
 }

 byte_track::STrack::~STrack()
@@ -39,6 +41,14 @@ const float& byte_track::STrack::getScore() const
 {
     return score_;
 }
+const int& byte_track::STrack::getClassId() const
+{
+    return class_id_;
+}
+const std::unordered_map<int, int>& byte_track::STrack::getClassCount() const
+{
+    return class_count_;
+}

 const size_t& byte_track::STrack::getTrackId() const
 {
@@ -60,9 +70,24 @@ const size_t& byte_track::STrack::getTrackletLength() const
     return tracklet_len_;
 }

+void byte_track::STrack::updateClass(int new_class_id)
+{
+    if (new_class_id == class_id_) {
+        ++class_count_[class_id_];
+        return;
+    }
+
+    auto it = class_count_.find(new_class_id);
+    if (it == class_count_.end()) class_count_[new_class_id] = 1;
+    else {
+        ++it->second;
+        if (it->second > class_count_[class_id_]) class_id_ = new_class_id;
+    }
+}
+
 void byte_track::STrack::activate(const size_t& frame_id, const size_t& track_id)
 {
-    kalman_filter_.initiate(mean_, covariance_, rect_.getXyah());
+    kalman_filter_.initiate(mean_, covariance_, rect_.getXyzolwh());

     updateRect();

@@ -79,13 +104,14 @@ void byte_track::STrack::activate(const size_t& frame_id, const size_t& track_id

 void byte_track::STrack::reActivate(const STrack &new_track, const size_t &frame_id, const int &new_track_id)
 {
-    kalman_filter_.update(mean_, covariance_, new_track.getRect().getXyah());
+    kalman_filter_.update(mean_, covariance_, new_track.getRect().getXyzolwh(), new_track.getScore());

     updateRect();

     state_ = STrackState::Tracked;
     is_activated_ = true;
     score_ = new_track.getScore();
+    updateClass(new_track.getClassId());
     if (0 <= new_track_id)
     {
         track_id_ = new_track_id;
@@ -96,22 +122,23 @@ void byte_track::STrack::reActivate(const STrack &new_track, const size_t &frame

 void byte_track::STrack::predict()
 {
-    if (state_ != STrackState::Tracked)
-    {
-        mean_[7] = 0;
-    }
+    // if (state_ != STrackState::Tracked)
+    // {
+    //     mean_[7] = 0;
+    // }
     kalman_filter_.predict(mean_, covariance_);
 }

 void byte_track::STrack::update(const STrack &new_track, const size_t &frame_id)
 {
-    kalman_filter_.update(mean_, covariance_, new_track.getRect().getXyah());
+    kalman_filter_.update(mean_, covariance_, new_track.getRect().getXyzolwh(), new_track.getScore());

     updateRect();

     state_ = STrackState::Tracked;
     is_activated_ = true;
     score_ = new_track.getScore();
+    updateClass(new_track.getClassId());
     frame_id_ = frame_id;
     tracklet_len_++;
 }
@@ -128,8 +155,11 @@ void byte_track::STrack::markAsRemoved()

 void byte_track::STrack::updateRect()
 {
-    rect_.width() = mean_[2] * mean_[3];
-    rect_.height() = mean_[3];
-    rect_.x() = mean_[0] - rect_.width() / 2;
-    rect_.y() = mean_[1] - rect_.height() / 2;
+    rect_.length() = mean_[4];
+    rect_.width() = mean_[5];
+    rect_.height() = mean_[6];
+    rect_.x() = mean_[0];
+    rect_.y() = mean_[1];
+    rect_.z() = mean_[2];
+    rect_.yaw() = mean_[3];
 }
--
2.34.1
