#!/usr/bin/env bash
# Copyright (c) 2025-present WATonomous. All rights reserved.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# Copyright (c) 2025‑present WATonomous.
# SPDX‑License‑Identifier: Apache‑2.0
set -euo pipefail

programname="$(basename "$(test -L "$0" && readlink "$0" || echo "$0")")"

# Discover monorepo directory by searching up from current directory
find_monorepo_root() {
  local dir="$PWD"
  while [[ "$dir" != "/" ]]; do
    if [[ -f "$dir/watod-config.sh" ]]; then
      echo "$dir"
      return 0
    fi
    dir="$(dirname "$dir")"
  done

  # Fallback to script location if not found
  cd -- "$(dirname -- "$(realpath "$0")")" && pwd
}

MONO_DIR="$(find_monorepo_root)"
MODULES_DIR="$MONO_DIR/modules"

# Always arrays → safe to expand with "${arr[@]}"
declare -a COMPOSE_CMD=()

usage() {
  cat <<EOF
Usage: $programname [OPTIONS]... [COMMAND]...

Executes 'docker compose COMMAND' in the monorepo with the correct
compose files and environment variables.

Options
  -v, --verbose               Print env setup output
  -m, --module MODULE         Add a specific module (can be used multiple times)
                              Use "all" for all modules
                              Append :dev for dev mode (e.g., -m perception:dev)
  -t, --terminal SERVICE      Run 'docker compose up -d' (if needed) and open
                              a bash shell in the SERVICE container
  -h, --help                  Show this help and exit

Commands
  install                     Install watod to /usr/local/bin (requires sudo)
  down                        Stop ACTIVE_MODULES containers + infrastructure
  down all                    Stop all watod containers (all modules/profiles)
  test [SERVICE]...           Run colcon test in specified service(s)
                              If no SERVICE specified, runs in all services
  bag <ros2-bag-args>...      Run ros2 bag commands (record/play/info/etc)
                              Runs in ./bags directory with auto-mounting

Examples
  watod up                              # docker compose up
  watod ps --services                   # docker compose ps --services
  watod -m all up                       # start all modules in deploy mode
  watod -m all:dev up                   # start all modules in dev mode
  watod down                            # stop ACTIVE_MODULES + infrastructure
  watod down all                        # stop all watod containers
  watod -m perception down              # stop only perception module (no infrastructure)
  watod -m perception -m action up      # start only perception and action
  watod -m perception:dev up            # start perception in dev mode
  watod -t perception                   # open a shell in the 'perception' service
  watod test                            # run tests in all services
  watod test perception                 # run tests only in perception service
  watod bag record -a                   # record all topics (auto-saves to ./bags)
  watod bag play my_bag                 # play bag from ./bags directory
  watod bag info my_bag                 # show bag info

More info: https://docs.docker.com/compose/reference/overview/
EOF
}

# Get all available modules
# Returns list of modules (excludes infrastructure which is added automatically)
get_all_modules() {
  echo "action"
  echo "interfacing"
  echo "perception"
  echo "world_modeling"
  echo "simulation"
}

# Parse ACTIVE_MODULES and build profile arrays
# Input: ACTIVE_MODULES can contain "module", "module:dev", "all", or "all:dev"
# Output: ALL_PROFILES, PRE_PROFILES arrays
# Args:
#   $1 - blacklist: space-separated list of modules to exclude (optional)
#   $2 - all_variants: if "true", include both dev and non-dev profiles for all modules
build_profile_arrays() {
  local blacklist=${1:-""}
  local all_variants=${2:-"false"}

  ALL_PROFILES=()
  PRE_PROFILES=()

  # If all_variants is true, build profiles for all modules (both dev and non-dev)
  if [[ "$all_variants" == "true" ]]; then
    for module in $(get_all_modules); do
      PRE_PROFILES+=( "${module}_pre" )
      ALL_PROFILES+=( "$module" )
      ALL_PROFILES+=( "${module}_dev" )
    done
    # Add infrastructure profiles
    PRE_PROFILES+=( "infrastructure_pre" )
    ALL_PROFILES+=( "infrastructure" )
    # Add both carla profiles
    ALL_PROFILES+=( "carla_gpu" )
    ALL_PROFILES+=( "carla_no_gpu" )
    return
  fi

  # Check if "all" or "all:dev" is in ACTIVE_MODULES
  local has_all=false
  local all_is_dev=false

  for m in "${ACTIVE_MODULES[@]}"; do
    if [[ "$m" == "all" ]]; then
      has_all=true
      break
    elif [[ "$m" == "all:dev" ]]; then
      has_all=true
      all_is_dev=true
      break
    fi
  done

  # If "all" is specified, expand it to all available modules
  if $has_all; then
    local all_modules
    all_modules=$(get_all_modules)
    ACTIVE_MODULES=()

    while IFS= read -r module; do
      [[ -z "$module" ]] && continue
      if $all_is_dev; then
        ACTIVE_MODULES+=("$module:dev")
      else
        ACTIVE_MODULES+=("$module")
      fi
    done <<< "$all_modules"
  fi

  # ACTIVE_MODULES is already an array
  for m in "${ACTIVE_MODULES[@]}"; do
    local module_name="$m"
    local is_dev=false

    # Check if this is a dev module
    if [[ "$m" == *":dev" ]]; then
      module_name="${m%:dev}"
      is_dev=true
    fi

    # Skip if module is in blacklist
    if [[ -n "$blacklist" && " $blacklist " =~ \ $module_name\  ]]; then
      continue
    fi

    # Always add pre profile (just the name, no --profile flag)
    PRE_PROFILES+=( "$module_name"_pre )

    # Add to ALL_PROFILES (just the name, no --profile flag)
    if $is_dev; then
      ALL_PROFILES+=( "$module_name"_dev )
    else
      ALL_PROFILES+=( "$module_name" )
    fi
  done

  # Always add infrastructure profiles (unless in CI or in blacklist)
  if [[ -z ${CI:-} && -z ${GITHUB_ACTIONS:-} ]]; then
    if [[ -z "$blacklist" || ! " $blacklist " =~ \ infrastructure\  ]]; then
      PRE_PROFILES+=( "infrastructure_pre" )
      ALL_PROFILES+=( "infrastructure" )
    fi
  fi

  # Add CARLA render mode profile if simulation is active
  for profile in "${ALL_PROFILES[@]}"; do
    if [[ "$profile" == "simulation" || "$profile" == "simulation_dev" ]]; then
      local carla_mode="${CARLA_RENDER_MODE:-no_gpu}"
      if [[ "$carla_mode" == "gpu" ]]; then
        ALL_PROFILES+=( "carla_gpu" )
      else
        ALL_PROFILES+=( "carla_no_gpu" )
      fi
      break
    fi
  done
}

# ─────────────────────────── Argument parsing ────────────────────────────

[[ $# -eq 0 ]] && usage && exit 0

# Array to collect modules from CLI flags
declare -a CLI_MODULES=()

while [[ $# -gt 0 ]]; do
  case $1 in
    -v|--verbose)
      VERBOSE=1
      shift
      ;;
    -m|--module)
      shift
      MODULE_NAME=${1:-}
      [[ -z $MODULE_NAME ]] && { echo "Missing module name after -m/--module"; usage; exit 1; }
      CLI_MODULES+=("$MODULE_NAME")
      shift
      ;;
    -t|--terminal)
      START_TERMINAL=1
      shift
      SERVICE_NAME=${1:-}
      [[ -z $SERVICE_NAME ]] && { echo "Missing service name after -t"; usage; exit 1; }
      shift
      ;;
    -h|--help|help)
      usage; exit 0 ;;
    install)
      "$MONO_DIR/watod_scripts/watod-install.sh"
      exit $?
      ;;
    test)
      RUN_TESTS=1
      shift
      # Collect service names if provided
      declare -a TEST_SERVICES=()
      while [[ $# -gt 0 && ! "$1" =~ ^- ]]; do
        TEST_SERVICES+=("$1")
        shift
      done
      break ;;
    bag)
      RUN_BAG=1
      shift
      # Pass all remaining arguments to watod-bag.sh
      BAG_ARGS=( "$@" )
      break ;;
    down)
      RUN_DOWN=1
      shift
      # Collect service names if provided
      declare -a DOWN_SERVICES=()
      while [[ $# -gt 0 && ! "$1" =~ ^- ]]; do
        DOWN_SERVICES+=("$1")
        shift
      done
      break ;;
    *)  # first non‑option → rest is docker‑compose cmd
      break ;;
  esac
done

# The remaining CLI words are the compose sub‑command and its flags
COMPOSE_CMD=( "$@" )

# ─────────────────────────── Environment setup ───────────────────────────

# Config files (local overrides main)
[[ -f "$MONO_DIR/watod-config.sh"       ]] && source "$MONO_DIR/watod-config.sh"
[[ -f "$MONO_DIR/watod-config.local.sh" ]] && source "$MONO_DIR/watod-config.local.sh"

# ────────────────────────────── Run Down ─────────────────────────────────
# Handle 'down' command
if [[ -n ${RUN_DOWN:-} ]]; then
  cd "$MONO_DIR"

  if [[ ${#DOWN_SERVICES[@]} -gt 0 && "${DOWN_SERVICES[0]}" == "all" ]]; then
    # "watod down all" - stop everything (all modules, all variants)
    build_profile_arrays "" "true"
  elif [[ ${#CLI_MODULES[@]} -gt 0 ]]; then
    # "watod -m <module> down" - stop only the specified module (no infrastructure)
    ACTIVE_MODULES=("${CLI_MODULES[@]}")
    build_profile_arrays "infrastructure"
  else
    # "watod down" - stop modules from ACTIVE_MODULES config + infrastructure
    # Need to determine ACTIVE_MODULES from config (already sourced above)
    if [[ -z ${ACTIVE_MODULES+x} ]]; then
      ACTIVE_MODULES=()
    elif [[ ! ${ACTIVE_MODULES@a} =~ a ]]; then
      # ACTIVE_MODULES is set but not an array, convert it
      # shellcheck disable=SC2128
      read -ra ACTIVE_MODULES <<<"$ACTIVE_MODULES"
    fi

    if [[ ${#ACTIVE_MODULES[@]} -eq 0 ]]; then
      echo "Error: No modules to stop. Set ACTIVE_MODULES in watod-config.sh or use:" >&2
      echo "  watod down all              # stop all watod containers" >&2
      echo "  watod -m perception down    # stop only perception module" >&2
      exit 1
    fi

    build_profile_arrays ""
  fi

  # Convert to --profile flags
  DOWN_PROFILE_FLAGS=()
  for p in "${ALL_PROFILES[@]}"; do
    DOWN_PROFILE_FLAGS+=("--profile" "$p")
  done

  docker compose --env-file modules/.env -f modules/docker-compose.yaml -f modules/docker-compose.dep.yaml -f modules/docker-compose.dev.yaml "${DOWN_PROFILE_FLAGS[@]}" down
  exit $?
fi

# Determine ACTIVE_MODULES: CLI flags take precedence over config
if [[ ${#CLI_MODULES[@]} -gt 0 ]]; then
  # Use modules specified via CLI flags
  ACTIVE_MODULES=("${CLI_MODULES[@]}")
elif [[ -z ${ACTIVE_MODULES+x} ]]; then
  # ACTIVE_MODULES not set, initialize as empty array
  ACTIVE_MODULES=()
elif [[ ! ${ACTIVE_MODULES@a} =~ a ]]; then
  # ACTIVE_MODULES is set but not an array, convert it
  # shellcheck disable=SC2128
  read -ra ACTIVE_MODULES <<<"$ACTIVE_MODULES"
fi

# Check if any modules were specified
if [[ ${#ACTIVE_MODULES[@]} -eq 0 ]]; then
  echo "Error: No modules specified. Use -m/--module or set ACTIVE_MODULES in watod-config.sh" >&2
  echo "Example: watod -m perception up" >&2
  echo "         watod -m all up" >&2
  exit 1
fi

# Save original ACTIVE_MODULES before watod-setup-env.sh adds infrastructure
ORIGINAL_ACTIVE_MODULES=("${ACTIVE_MODULES[@]}")

# Generate .env via helper script
if [[ -n ${VERBOSE:-} ]]; then
    pushd "$MONO_DIR" > /dev/null
    source ./watod_scripts/watod-setup-env.sh          # env vars persist
    popd > /dev/null
else
    pushd "$MONO_DIR" > /dev/null
    source ./watod_scripts/watod-setup-env.sh &>/dev/null
    popd > /dev/null
fi

# ────────────────────────────── Run Tests ────────────────────────────────

if [[ -n ${RUN_TESTS:-} ]]; then
  # Temporarily set ACTIVE_MODULES to only test user-specified modules (not infrastructure)
  SAVED_ACTIVE_MODULES=("${ACTIVE_MODULES[@]}")
  ACTIVE_MODULES=("${ORIGINAL_ACTIVE_MODULES[@]}")

  # Build test profiles array from original modules only
  build_profile_arrays ""

  # Call the test script with profiles as arguments
  if [[ ${#TEST_SERVICES[@]} -gt 0 ]]; then
    "$MONO_DIR/watod_scripts/watod-test.sh" --pre-profiles "${PRE_PROFILES[@]}" --all-profiles "${ALL_PROFILES[@]}" "${TEST_SERVICES[@]}"
  else
    "$MONO_DIR/watod_scripts/watod-test.sh" --pre-profiles "${PRE_PROFILES[@]}" --all-profiles "${ALL_PROFILES[@]}"
  fi

  # Restore ACTIVE_MODULES
  ACTIVE_MODULES=("${SAVED_ACTIVE_MODULES[@]}")
  exit $?
fi

# ────────────────────────────── Run Bag ──────────────────────────────

if [[ -n ${RUN_BAG:-} ]]; then
  # Export variables needed by watod-bag.sh
  export MONO_DIR MODULES_DIR BAG_DIRECTORY INFRASTRUCTURE_IMAGE TAG
  export RMW_IMPLEMENTATION ROS_DOMAIN_ID COMPOSE_PROJECT_NAME
  export ZENOH_ROUTER_CONFIG_URI ZENOH_SESSION_CONFIG_URI
  "$MONO_DIR/watod_scripts/watod-bag.sh" "${BAG_ARGS[@]}"
  exit $?
fi

# ─────────────────────────── Execute compose ─────────────────────────────

if [[ ${#COMPOSE_CMD[@]} -gt 0 ]]; then
  # Build profile arrays
  build_profile_arrays ""

  # Delegate to watod-compose.sh
  "$MONO_DIR/watod_scripts/watod-compose.sh" "${COMPOSE_CMD[@]}" --pre-profiles "${PRE_PROFILES[@]}" --all-profiles "${ALL_PROFILES[@]}"
fi

# Open interactive shell if requested
if [[ -n ${START_TERMINAL:-} ]]; then
  # Build profile arrays
  build_profile_arrays ""

  # Check if service is running
  if ! docker compose -f "$MONO_DIR/modules/docker-compose.yaml" ps "$SERVICE_NAME" 2>/dev/null | grep -q "Up"; then
    echo "Error: Service '$SERVICE_NAME' is not running." >&2
    exit 1
  fi

  echo "Opening bash shell in service '$SERVICE_NAME'..."
  "$MONO_DIR/watod_scripts/watod-compose.sh" exec -it -e TERM="${TERM:-xterm-256color}" "$SERVICE_NAME" /bin/bash --pre-profiles "${PRE_PROFILES[@]}" --all-profiles "${ALL_PROFILES[@]}"
fi
